･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！
上集我们讲了数据存储，磁带和硬盘这样的技术
可以在断电状态长时间存上万亿个位
可以在断电状态长时间存上万亿个位
非常合适存一整块有关系的数据，或者说"文件"
非常合适存一整块有关系的数据，或者说"文件"
你肯定见过很多种文件 \N 比如文本文件，音乐文件，照片和视频
你肯定见过很多种文件 \N 比如文本文件，音乐文件，照片和视频
今天，我们要讨论文件到底是什么 \N 以及计算机怎么管理文件
今天，我们要讨论文件到底是什么 \N 以及计算机怎么管理文件
随意排列文件数据完全没问题，但按格式排会更好
随意排列文件数据完全没问题，但按格式排会更好
这叫 "文件格式"
你可以发明自己的文件格式，程序员偶尔会这样做
但最好用现成标准，比如 JPEG 和 MP3
来看一些简单文件格式，最简单的是文本文件
来看一些简单文件格式，最简单的是文本文件
也叫 TXT 文件, 里面包含的是... 文字 （惊喜吧）
就像所有其它文件，文本文件只是一长串二进制数
原始值看起来会像这样：
可以转成十进制看，但帮助不大
可以转成十进制看，但帮助不大
解码数据的关键是 ASCII 编码
一种字符编码标准，第 4 集讨论过.
第一个值 72 \N 在 ASCII 中是大写字母 H
以此类推 解码其他数字
来看一个更复杂的例子：波形(Wave)文件，也叫 WAV \N 它存音频数据
来看一个更复杂的例子：波形(Wave)文件，也叫 WAV \N 它存音频数据
在正确读取数据前，需要知道一些信息
比如码率(bit rate)，以及是单声道还是立体声
关于数据的数据，叫"元数据"(meta data)
元数据存在文件开头，在实际数据前面 \N 因此也叫 文件头(Header)
元数据存在文件开头，在实际数据前面 \N 因此也叫 文件头(Header)
WAV 文件的前 44 个字节长这样
有的部分总是一样的，比如写着 WAVE 的部分
其他部分的内容，会根据数据变化
音频数据紧跟在元数据后面，是一长串数字
数字代表每秒捕获多次的声音幅度
如果想学声音的基础知识 \N 可以看物理速成课第18集
如果想学声音的基础知识 \N 可以看物理速成课第18集
举个例子，看一下"你好"的波形
现在捕获到了一些声音，我们放大看一下
电脑和手机麦克风，每秒可以对声音进行上千次采样
电脑和手机麦克风，每秒可以对声音进行上千次采样
每次采样可以用一个数字表示
声压越高数字越大，也叫"振幅"
WAVE 文件里存的就是这些数据！
每秒上千次的振幅！
播放声音文件时，扬声器会产生相同的波形
播放声音文件时，扬声器会产生相同的波形
"你好！"
现在来谈谈 位图(Bitmap)，后缀 .bmp, 它存图片
现在来谈谈 位图(Bitmap)，后缀 .bmp, 它存图片
计算机上，图片由很多个叫"像素"的方块组成
每个像素由三种颜色组成：红，绿，蓝
叫"加色三原色"，混在一起可以创造其它颜色
叫"加色三原色"，混在一起可以创造其它颜色
就像 WAV 文件一样，BMP 文件开头也是元数据 \N 有图片宽度，图片高度，颜色深度
就像 WAV 文件一样，BMP 文件开头也是元数据 \N 有图片宽度，图片高度，颜色深度
举例，假设元数据说图是 4像素宽 x 4像素高
颜色深度 24 位\N  8 位红色，8 位绿色，8 位蓝色
提醒一下，8位 (bit) 和 1字节(byte)是一回事
一个字节能表示的最小数是 0，最大 255
图像数据看起来会类似这样：\N 来看看第一个像素的颜色
图像数据看起来会类似这样：\N 来看看第一个像素的颜色
红色是255，绿色是255，蓝色也是255
这等同于全强度红色，全强度绿色和全强度蓝色
混合在一起变成白色
所以第一个像素是白色！
下一个像素的红绿蓝值，或 RGB 值 \N  255,255,0 是黄色！
下一个像素的红绿蓝值，或 RGB 值 \N  255,255,0 是黄色！
下一个像素是 0,0,0 ，黑色
下一个是黄色
因为元数据说图片是 4x4 \N 我们知道现在到了第一行结尾
因为元数据说图片是 4x4 \N 我们知道现在到了第一行结尾
所以换一行
下一个 RGB 值是 255,255,0，又是黄色
好，我们读完剩下的像素
一个低分辨率的吃豆人
刚才显然只是一个简单例子，但这张图片也可以用 BMP 存
刚才显然只是一个简单例子，但这张图片也可以用 BMP 存
我想再次强调，不管是文本文件，WAV，BMP
或是我们没时间讨论的其他格式
文件在底层全是一样的： 一长串二进制
为了知道文件是什么，文件格式至关重要
现在你对文件更了解了 \N 我们接下来讨论计算机怎么存文件
现在你对文件更了解了 \N 我们接下来讨论计算机怎么存文件
虽然硬件可能是磁带，磁鼓，磁盘或集成电路
虽然硬件可能是磁带，磁鼓，磁盘或集成电路
通过软硬件抽象后，可以看成一排能存数据的桶
通过软硬件抽象后，可以看成一排能存数据的桶
在很早期时，计算机只做一件事，比如算火炮射程表 \N 整个储存器就像一整个文件
在很早期时，计算机只做一件事，比如算火炮射程表 \N 整个储存器就像一整个文件
数据从头存到尾，直到占满
数据从头存到尾，直到占满
但随着计算能力和存储容量的提高 \N 存多个文件变得非常有用
但随着计算能力和存储容量的提高 \N 存多个文件变得非常有用
最简单的方法  是把文件连续存储
这样能用, \N 但怎么知道文件开头和结尾在哪里？
储存器没有文件的概念，只是存储大量位
所以为了存多个文件 \N 需要一个特殊文件，记录其他文件的位置
这个特殊文件有很多名字，这里泛称 "目录文件"
这个文件经常存在最开头，方便找
位置 0！
目录文件里，存所有其他文件的名字
格式是文件名 + 一个句号 + 扩展名，比如 BMP 或 WAV
格式是文件名 + 一个句号 + 扩展名，比如 BMP 或 WAV
扩展名帮助得知文件类型
目录文件还存文件的元数据，比如创建时间
最后修改时间，文件所有者是谁\N是否能读
写  或读写都行
最重要的是，目录文件有文件起始位置和长度
最重要的是，目录文件有文件起始位置和长度
如果要添加文件，删除文件，更改文件名等
必须更新目录文件
就像书的目录，如果缩短或移动了一个章节 \N 要更新目录，不然页码对不上
就像书的目录，如果缩短或移动了一个章节 \N 要更新目录，不然页码对不上
目录文件，以及对目录文件的管理 \N 是一个非常简单的文件系统例子
文件系统专门负责管理文件
刚刚的例子叫"平面文件系统" \N因为文件都在同一个层次
平的！
当然，把文件前后排在一起  有个问题
如果给 todo.txt 加一点数据 \N 会覆盖掉后面 carrie.bmp 的一部分
如果给 todo.txt 加一点数据 \N 会覆盖掉后面 carrie.bmp 的一部分
所以现代文件系统会做两件事
1. 把空间划分成一块块 \N 导致有一些 "预留空间" 可以方便改动
1. 把空间划分成一块块 \N 导致有一些 "预留空间" 可以方便改动
同时也方便管理
用这样的方案，目录文件要记录文件在哪些块里
用这样的方案，目录文件要记录文件在哪些块里
2. 拆分文件，存在多个块里
2. 拆分文件，存在多个块里
假设打开 todo.txt 加了些内容\N 文件太大存不进一块里
假设打开 todo.txt 加了些内容\N 文件太大存不进一块里
我们不想覆盖掉隔壁的块，所以文件系统会分配 \N 一个没使用的块，容纳额外的数据
我们不想覆盖掉隔壁的块，所以文件系统会分配 \N 一个没使用的块，容纳额外的数据
目录文件会记录不止一个块，而是多个块
目录文件会记录不止一个块，而是多个块
只要分配块，文件可以轻松增大缩小
只要分配块，文件可以轻松增大缩小
如果你看了第18集 操作系统 \N 这听起来很像"虚拟内存"
概念上讲的确很像！
假设想删掉 carrie.bmp \N 只需要在目录文件删掉那条记录
假设想删掉 carrie.bmp \N 只需要在目录文件删掉那条记录
让一块空间变成了可用
注意这里没有擦除数据，只是把记录删了
之后某个时候，那些块会被新数据覆盖 \N 但在此之前，数据还在原处
所以计算机取证团队可以"恢复"数据
虽然别人以为数据已经"删了", 狡猾！
假设往 todo.txt 加了更多数据 \N 所以操作系统分配了一个新块，用了刚刚 carrie.bmp 的块
假设往 todo.txt 加了更多数据 \N 所以操作系统分配了一个新块，用了刚刚 carrie.bmp 的块
假设往 todo.txt 加了更多数据 \N 所以操作系统分配了一个新块，用了刚刚 carrie.bmp 的块
现在 todo.txt 在 3 个块里，隔开了，顺序也是乱的
这叫碎片
碎片是增
删
改文件导致的，不可避免
对很多存储技术来说，碎片是坏事
如果 todo.txt 存在磁带上，读取文件要
先读块1, 然后快进到块5，然后往回转到块2
来回转个半天
现实世界中，大文件可能存在数百个块里
你可不想等五分钟才打开文件
答案是碎片整理！
这个词听起来好像很复杂，但实际过程很简单
以前看计算机做碎片整理 真的很有趣！
计算机会把数据来回移动，排列成正确的顺序
计算机会把数据来回移动，排列成正确的顺序
整理后 todo.txt 在 1 2 3，方便读取.
整理后 todo.txt 在 1 2 3，方便读取.
目前只说了平面文件系统，文件都在同一个目录里.
目前只说了平面文件系统，文件都在同一个目录里.
如果存储空间不多，这可能就够用了 \N 因为只有十几个文件
如果存储空间不多，这可能就够用了 \N 因为只有十几个文件
但上集说过，容量爆炸式增长，文件数量也飞速增长
但上集说过，容量爆炸式增长，文件数量也飞速增长
很快，所有文件都存在同一层变得不切实际
就像现实世界\N 相关文件放在同一个文件夹会方便很多
然后文件夹套文件夹.
这叫"分层文件系统"，你的计算机现在就在用这个.
实现方法有很多种，我们用之前的例子来讲重点好了
实现方法有很多种，我们用之前的例子来讲重点好了
最大的变化是 目录文件不仅要指向文件, 还要指向目录
最大的变化是 目录文件不仅要指向文件, 还要指向目录
我们需要额外元数据  来区分开文件和目录，
这个目录文件在最顶层，因此叫根目录
所有其他文件和文件夹，都在根目录下
图中可以看到根目录文件有3个文件 \N 2个子文件夹："音乐"和"照片"
图中可以看到根目录文件有3个文件 \N 2个子文件夹："音乐"和"照片"
如果想知道"音乐"文件夹里有什么 \N 必须去那边读取目录文件（格式和根目录文件一样）
如果想知道"音乐"文件夹里有什么 \N 必须去那边读取目录文件（格式和根目录文件一样）
有很多好歌啊！
除了能做无限深度的文件夹 \N 这个方法也让我们可以轻松移动文件
除了能做无限深度的文件夹 \N 这个方法也让我们可以轻松移动文件
如果想把 theme.wav 从根目录移到音乐目录
不用移动任何数据块
只需要改两个目录文件 \N 一个文件里删一条记录，另一个文件里加一条记录
theme.wav 依然在块5
文件系统的几个重要概念  现在介绍完了.
它提供了一层新抽象！
文件系统使我们不必关心 \N 文件在磁带或磁盘的具体位置
整理和访问文件更加方便
我们像普通用户一样直观操纵数据，比如打开和整理文件
我们像普通用户一样直观操纵数据，比如打开和整理文件
接下来几集也会从用户角度看问题
下周见